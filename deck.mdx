import { CodeSurfer } from "mdx-deck-code-surfer";
import { Appear, Head } from "mdx-deck";
import { Split } from "mdx-deck/layouts";

export { default as theme } from "./theme";
import { codeTheme, dark } from "./theme";

import App from "../example-js/src/SimpleExample/App";

# Typsäker frontend i TypeScript | ReasonML

---

# Pontus Nagy

### @p1xelHer0

```notes
twitter, github, osv
```

---

## Vem är jag?

<br />

<Appear>
  <div>JavaScript/AngularJS</div>
  <div>ES6/React/Redux</div>
  <div>Haskell *</div>
  <div>OCaml/ReasonML *</div>
  <div>TypeScript</div>
</Appear>

```notes
Första jobb

Andra jobb

Redux -> FP + Typer

Galen i funktionella typade språk

* Ej jobb, endast fritid

Nytt uppdrag, nytt språk, TypeScript
```

---

## Dynamiskt -> Statiskt

### Typer

```notes
Min resa

Vi ska prata om typer, i form av TypeScript
```

---

## Varför typer?

```notes
målet är "aah, därför!"
```

---

## Typer => Säkerhet

### "Typsäker"

```notes
Vad menar jag?

"Låt datorn hålla koll"
```

---

## "Säkerhet"

<Appear>
  <div>Refaktorering</div>
  <div>"Dokumentation"</div>
  <div>"Make illegal states unrepresentable"</div>
</Appear>

```notes
Agila team, iterativt med krav som ändras

Typer kan bestämma logik och fungera som delvis dokumentation

Miljöer bortom kod kan ha problem, testning och blabla
```

---

## Hur?

### TypeScript

```notes
Det är ju detta seminariet handlar om!
```

---

_TypeScript is a typed superset of JavaScript that compiles to plain JavaScript._

##### - typescriptlang.org

```notes
Allt som är JavaScript kan också kompileras av TypeScript.

Värdefullt i editor-tooling, utan compiler i kodbas!
```

---

... is a **_typed_** superset ...

```notes
Var är en typ?
```

---

<CodeSurfer
  title="JavaScript"
  code={require("!raw-loader!./assets/Functions.js")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { range: [7, 7 + 2], notes: "" },
    { lines: [11], notes: "" },
    { lines: [13], notes: "" },
    {},
  ]}
/>

```notes
JavaScript
```

---

<CodeSurfer
  title="TypeScript"
  code={require("!raw-loader!./assets/FunctionsTSCompiler.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { range: [7, 7 + 2], notes: "" },
    { lines: [11], notes: "" },
    { range: [13, 15], notes: "" },
    {},
  ]}
/>

```notes
TypeScript!

"Type inference"

word, ej typ ännu, "!" är dock det
olika varianter av plus
```

---

<CodeSurfer
  title="Annoteringar"
  code={require("!raw-loader!./assets/Functions.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { tokens: { 1: [3, 4, 5, 6, 7, 8] }, notes: "string" },
    { tokens: { 1: [9, 10, 11, 12] }, notes: "void" },
    {
      tokens: { 1: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] },
      notes: "(name: string) => void",
    },
    { tokens: { 5: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] }, notes: "" },
    {
      tokens: { 5: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] },
      notes: "(word: string) => string",
    },
    { tokens: { 7: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] }, notes: "" },
    {
      tokens: { 7: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] },
      notes: "(name: string) => void",
    },
    { lines: [11], notes: "" },
    { range: [13, 13 + 2], notes: "" },
    {},
  ]}
/>

```notes

```

---

<CodeSurfer
  title="Typer"
  code={require("!raw-loader!./assets/BasicTypes.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 1], notes: "" },
    { range: [4, 4 + 1], notes: "" },
    { range: [7, 7 + 1], notes: "" },
    { range: [10, 10 + 2], notes: "" },
    { range: [13, 13 + 2], notes: "" },
    {},
  ]}
/>

```notes
Boolean

Number

String

Array, endast en typ T, variabel längd

Tuple, nytt! Flera typer, fix längd
```

---

<CodeSurfer
  title="Polymorphism"
  code={require("!raw-loader!./assets/Polymorphism.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 1], notes: "" },
    { range: [3, 3 + 3], notes: "" },
    { lines: [8], notes: "" },
    { lines: [10], notes: "" },
    { lines: [11], notes: "" },
    { range: [10, 11], notes: "" },
    {},
  ]}
/>

```notes
Varör är dom spännande?

En typ som tar en typ som parameter

Funktion -> Typ
```

---

<CodeSurfer
  title="Interfaces"
  code={require("!raw-loader!./assets/Interfaces.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [7, 7 + 7], notes: "" },
    {},
  ]}
/>

```notes
Varör är dom spännande?

En typ som tar en typ som parameter

Funktion -> Typ
```

---

## Recap

<Appear>
  <div>Typer</div>
  <div>Polymorphism</div>
  <div>Interfaces</div>
  <div>Egna typer</div>
</Appear>

```notes
Typer

Polymorphism, typer som tar typer som parameter

Typer bestående av andra typer

Definiera egna typer, type keyword
```

---

# 🤙 ➞ 🌀 ➞ 📊

```notes
Tjena resurs, ge mig data

Visa spinner

Få tillbaka paketet, data

Visa data
```

---

<CodeSurfer
  title="Interfaces"
  code={require("!raw-loader!./assets/1State.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [6, 6 + 4], notes: "" },
    {},
  ]}
/>

```notes
datafrom ej relevat
```

---

<CodeSurfer
  title="🤙 ➞ 🌀 ➞ 📊"
  code={require("!raw-loader!./assets/1StateUse.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 3], notes: "🤙" },
    { range: [6, 6 + 1], notes: "🌀" },
    { range: [9, 9 + 3], notes: "📊" },
    {},
  ]}
/>

```notes
börja bolla frågan, problem?

vi kan vara explicitare, vi har TS!
```

---

## --strictNullCheck

```notes
compiler-inställning

inkrementel adoption

hantera null som ett unikt värde

säkrare kod!
```

---

<CodeSurfer
  title="🤙 ➞ 🌀 ➞ 📊"
  code={require("!raw-loader!./assets/1StateUse.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[{ range: [1, 1 + 5], notes: "" }]}
/>

```notes
null !== data
```

---

## |

<Appear>
  <div>||</div>
  <div>const v = a || 0;</div>
  <div>"eller"</div>
  <div>disjunktion</div>
</Appear>

```notes
"pipe"

förmodligen sett tidigare

vad TROR ni det betyder?
```

---

<CodeSurfer
  title="🤙 ➞ 🌀 ➞ 📊"
  code={require("!raw-loader!./assets/2State.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
/>

```notes

```

---

<CodeSurfer
  title="🤙 ➞ 🌀 ➞ 📊"
  code={require("!raw-loader!./assets/2StateUse.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
/>

```notes
nu funkar det!
```

---

## Union

```notes
union typ

vi ska visa några exempel
```

---

<CodeSurfer
  title="Union"
  code={require("!raw-loader!./assets/Union.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { lines: [1], notes: "" },
    { lines: [3], notes: "" },
    { range: [5, 5 + 7], notes: "" },
    { range: [14, 14 + 7], notes: "" },
    { range: [14, 14 + 9], notes: "" },
  ]}
/>

```notes
tillåter oss att specificera värden

kombination med tidigare sätt vi sett
```

---

<CodeSurfer
  title="Union som en mängd"
  code={require("!raw-loader!./assets/UnionInSets.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { lines: [6], notes: "" },
    { range: [6, 6 + 3], notes: "" },
  ]}
/>

```notes
tillbaka till skolan, mängdlära

addition och ta bort dubletter

union, syskon till produkt
```

---

<CodeSurfer
  title="Interface som en produkt"
  code={require("!raw-loader!./assets/InterfaceAsAProduct.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 3], notes: "" },
    { lines: [6], notes: "" },
    { lines: [8], notes: "" },
    { lines: [10], notes: "" },
    { lines: [11], notes: "" },
    { lines: [12], notes: "" },
    { lines: [13], notes: "" },
    { range: [8, 8 + 5], notes: "2 x 2 = 4" },
    { range: [1, 13], notes: "(1 + 1) x (1 + 1) = 4" },
  ]}
/>

```notes
Om | är union, då är interface en produkt
```

---

## 🤙 ➞ 🌀 ➞ 📊

<Appear>
  <div>{"{loading: false, data: null}"} 🤙</div>
  <div>{"{loading: true, data: null}"} 🌀</div>
  <div>{"{loading: false, data: data}"} 📊</div>
  <div>...</div>
  <div>{"{loading: true, data: data}"} 🐛</div>
</Appear>

```notes
Gå tillbaka till vår app

initialt värde

skicka frågan, visa spinner

få tillbaka, visa data

...

men det fjärde då? bug!

"trivialt", men om det existerar buggar i detta kontext, under hur mycket det finns i större applikationer
```

---

## Varför? - "Making illegale state unrepresentable"

### 🧨 🐛

```notes
3 states enligt krav, 4 enligt koden

dags att döda buggen

med det vi lärt oss om produkter, unioner och TypeScript
```

---

<Appear>
  <div>3 = x * y</div>
  <div>3 = x + y</div>
  <div>3 = 2 + 1</div>
  <br />
  <div>2 = 1 + 1</div>
  <div>3 = 1 + 1 + 1</div>
</Appear>

```notes
produkt eller summa? heltal! inga halva typer
```

---

<CodeSurfer
  title="Interface som en produkt"
  code={require("!raw-loader!./assets/UnionSolve1.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { lines: [1], notes: "" },
    { lines: [3], notes: "" },
    { range: [5, 5 + 1], notes: "" },
    { range: [8, 8 + 2], notes: "" },
  ]}
/>

```notes
union till räddning

ganska lätt att räkna
```

---

## ...

---

## Varför? - Refaktorering

```notes
jag har ett nytt förslag
```

---

## Diskriminering

```notes
men, jag har ett förslag

vi ska diskriminera...

våra unioner
```

---

<CodeSurfer
  title="Diskriminerad Union"
  code={require("!raw-loader!./assets/DiscriminatedUnion.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 6], notes: "" },
    { range: [9, 9 + 6], notes: "" },
    { range: [17, 17 + 8], notes: "" },
    { lines: [27], notes: "" },
  ]}
/>

```notes

```

---

<CodeSurfer
  title="🤙 ➞ 🌀 ➞ 📊"
  code={require("!raw-loader!./assets/DiscriminatedSwitch.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 26], notes: "" },
    { lines: [29], notes: "" },
    { range: [31, 31 + 1], notes: "" },
    { range: [34, 34 + 2], notes: "" },
    { range: [38, 38 + 9], notes: "" },
  ]}
/>

```notes

```

---

<CodeSurfer
  title="Refaktorering"
  code={require("!raw-loader!./assets/DiscriminatedSwitch2.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[{ range: [1, 1 + 5], notes: "" }, { range: [8, 8 + 9], notes: "" }]}
/>

```notes
vi vill hantera fel, lägg till det!

oj, koden kompilerar inte, undefined !== string

vi TVINGAS hantera switchen

"exhaustive pattern matching"
```

---

## Vad har vi lärt oss?

<Appear>
  <div>TypeScript, delvis!</div>
  <div>Polymorphism</div>
  <div>Mängdlära, Unioner och Produkter</div>
  <div>Diskriminerade Unioner</div>
</Appear>

```notes
type inference, typannoteringar, skapa våra egna typer

typer som tar typer som parameter, listor t.ex.
```

---

## Buzzword-check!

<Appear>
  <h3>Simplare</h3>
  <div>3 &lt; 4</div>
  <h3>Lättare att förändra</h3>
  <div>Exhaustive pattern matching</div>
  <h3>Korrektare</h3>
  <div>4 != 3</div>
</Appear>

```notes
förmågan att utrycka MINDRE är underskattad

vi tvingas hantera alla nya fall
```

---

## "Populära diskriminerade unioner"

```notes
illustrering av discriminated union i andra språk

koncept i språk som Haskell, Ocaml, Rust, nu i Java
```

---

<CodeSurfer
  title="Diskriminerade unioner"
  code={require("!raw-loader!./assets/Maybe.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 9], notes: "" },
    { range: [11, 11 + 11], notes: "" },
    {},
  ]}
/>

```notes
Optional i Java, istället för null

För att hämta pekare i Rust, inga null pointers!

I språk där null inte finns, t.ex. Haskell eller OCaml
```

---

## ...

---

---

## "... | ReasonML" ?

---

<CodeSurfer
  title="ReasonML"
  code={require("!raw-loader!./assets/Reason.re")}
  dark={dark}
  lang="reason"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [6, 6 + 7], notes: "" },
    {},
  ]}
/>

```notes
Statiskt typad funktionellt programmeringsspråk som kompileras till JS

Inget speciellt behövs för diskriminerade unioner

bättre type inference, den gissa bättre

Expressions istället för statements

Default immutability

TypeScript är jobb
Det här är coolt

Mer saker jag inte hinner berätta om!
```

---

## https://reasonml.github.io/

---

# Tack för att ni lyssnade❣️

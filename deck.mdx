import { CodeSurfer } from "mdx-deck-code-surfer";
import { Appear, Head } from "mdx-deck";
import { Split } from "mdx-deck/layouts";

export { default as theme } from "./theme";
import { codeTheme, dark } from "./theme";

import App from "../example-js/src/SimpleExample/App";

# Typs√§ker frontend i TypeScript | ReasonML

---

# Pontus Nagy

### @p1xelHer0

```notes
twitter, github, osv
```

---

## Vem √§r jag?

<br />

<Appear>
  <div>JavaScript/AngularJS</div>
  <div>ES6/React/Redux</div>
  <div>Haskell *</div>
  <div>OCaml/ReasonML *</div>
  <div>TypeScript</div>
</Appear>

```notes
F√∂rsta jobb

Andra jobb

Redux -> FP + Typer

Galen i funktionella typade spr√•k

* Ej jobb, endast fritid

Nytt uppdrag, nytt spr√•k, TypeScript
```

---

## Dynamiskt -> Statiskt

### Typer

```notes
Min resa

Vi ska prata om typer, i form av TypeScript
```

---

## Varf√∂r typer?

```notes
m√•let √§r "aah, d√§rf√∂r!"
```

---

## Typer => S√§kerhet

### "Typs√§ker"

```notes
Vad menar jag?

"L√•t datorn h√•lla koll"
```

---

## "S√§kerhet"

<Appear>
  <div>Refaktorering</div>
  <div>"Dokumentation"</div>
  <div>"Make illegal states unrepresentable"</div>
</Appear>

```notes
Agila team, iterativt med krav som √§ndras

Typer kan best√§mma logik och fungera som delvis dokumentation

Milj√∂er bortom kod kan ha problem, testning och blabla
```

---

## Hur?

### TypeScript

```notes
Det √§r ju detta seminariet handlar om!
```

---

_TypeScript is a typed superset of JavaScript that compiles to plain JavaScript._

##### - typescriptlang.org

```notes
Allt som √§r JavaScript kan ocks√• kompileras av TypeScript.

V√§rdefullt i editor-tooling, utan compiler i kodbas!
```

---

... is a **_typed_** superset ...

```notes
Var √§r en typ?
```

---

<CodeSurfer
  title="JavaScript"
  code={require("!raw-loader!./assets/Functions.js")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { range: [7, 7 + 2], notes: "" },
    { lines: [11], notes: "" },
    { lines: [13], notes: "" },
    {},
  ]}
/>

```notes
JavaScript
```

---

<CodeSurfer
  title="TypeScript"
  code={require("!raw-loader!./assets/FunctionsTSCompiler.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { range: [7, 7 + 2], notes: "" },
    { lines: [11], notes: "" },
    { range: [13, 15], notes: "" },
    {},
  ]}
/>

```notes
TypeScript!

"Type inference"

word, ej typ √§nnu, "!" √§r dock det
olika varianter av plus
```

---

<CodeSurfer
  title="Annoteringar"
  code={require("!raw-loader!./assets/Functions.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { tokens: { 1: [3, 4, 5, 6, 7, 8] }, notes: "string" },
    { tokens: { 1: [9, 10, 11, 12] }, notes: "void" },
    {
      tokens: { 1: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] },
      notes: "(name: string) => void",
    },
    { tokens: { 5: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] }, notes: "" },
    {
      tokens: { 5: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] },
      notes: "(word: string) => string",
    },
    { tokens: { 7: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] }, notes: "" },
    {
      tokens: { 7: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] },
      notes: "(name: string) => void",
    },
    { lines: [11], notes: "" },
    { range: [13, 13 + 2], notes: "" },
    {},
  ]}
/>

```notes

```

---

<CodeSurfer
  title="Typer"
  code={require("!raw-loader!./assets/BasicTypes.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 1], notes: "" },
    { range: [4, 4 + 1], notes: "" },
    { range: [7, 7 + 1], notes: "" },
    { range: [10, 10 + 2], notes: "" },
    { range: [13, 13 + 2], notes: "" },
    {},
  ]}
/>

```notes
Boolean

Number

String

Array, endast en typ T, variabel l√§ngd

Tuple, nytt! Flera typer, fix l√§ngd
```

---

<CodeSurfer
  title="Polymorphism"
  code={require("!raw-loader!./assets/Polymorphism.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 1], notes: "" },
    { range: [3, 3 + 3], notes: "" },
    { lines: [8], notes: "" },
    { lines: [10], notes: "" },
    { lines: [11], notes: "" },
    { range: [10, 11], notes: "" },
    {},
  ]}
/>

```notes
Var√∂r √§r dom sp√§nnande?

En typ som tar en typ som parameter

Funktion -> Typ
```

---

<CodeSurfer
  title="Interfaces"
  code={require("!raw-loader!./assets/Interfaces.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [7, 7 + 7], notes: "" },
    {},
  ]}
/>

```notes
Var√∂r √§r dom sp√§nnande?

En typ som tar en typ som parameter

Funktion -> Typ
```

---

## Recap

<Appear>
  <div>Typer</div>
  <div>Polymorphism</div>
  <div>Interfaces</div>
  <div>Egna typer</div>
</Appear>

```notes
Typer

Polymorphism, typer som tar typer som parameter

Typer best√•ende av andra typer

Definiera egna typer, type keyword
```

---

# ü§ô ‚ûû üåÄ ‚ûû üìä

```notes
Tjena resurs, ge mig data

Visa spinner

F√• tillbaka paketet, data

Visa data
```

---

<CodeSurfer
  title="Interfaces"
  code={require("!raw-loader!./assets/1State.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [6, 6 + 4], notes: "" },
    {},
  ]}
/>

```notes
datafrom ej relevat
```

---

<CodeSurfer
  title="ü§ô ‚ûû üåÄ ‚ûû üìä"
  code={require("!raw-loader!./assets/1StateUse.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 3], notes: "ü§ô" },
    { range: [6, 6 + 1], notes: "üåÄ" },
    { range: [9, 9 + 3], notes: "üìä" },
    {},
  ]}
/>

```notes
b√∂rja bolla fr√•gan, problem?

vi kan vara explicitare, vi har TS!
```

---

## --strictNullCheck

```notes
compiler-inst√§llning

inkrementel adoption

hantera null som ett unikt v√§rde

s√§krare kod!
```

---

<CodeSurfer
  title="ü§ô ‚ûû üåÄ ‚ûû üìä"
  code={require("!raw-loader!./assets/1StateUse2.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[{ range: [1, 1 + 5], notes: "" }]}
/>

```notes
null !== data
```

---

## |

<Appear>
  <div>||</div>
  <div>const v = a || 0;</div>
  <div>"eller"</div>
  <div>disjunktion</div>
</Appear>

```notes
"pipe"

f√∂rmodligen sett tidigare

vad TROR ni det betyder?
```

---

<CodeSurfer
  title="ü§ô ‚ûû üåÄ ‚ûû üìä"
  code={require("!raw-loader!./assets/2State.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
/>

```notes

```

---

<CodeSurfer
  title="ü§ô ‚ûû üåÄ ‚ûû üìä"
  code={require("!raw-loader!./assets/2StateUse.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
/>

```notes
nu funkar det!
```

---

## Union

```notes
union typ

vi ska visa n√•gra exempel
```

---

<CodeSurfer
  title="Union"
  code={require("!raw-loader!./assets/Union.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { lines: [1], notes: "" },
    { lines: [3], notes: "" },
    { range: [5, 5 + 7], notes: "" },
    { range: [14, 14 + 7], notes: "" },
    { range: [14, 14 + 9], notes: "" },
  ]}
/>

```notes
till√•ter oss att specificera v√§rden

kombination med tidigare s√§tt vi sett
```

---

<CodeSurfer
  title="Union som en m√§ngd"
  code={require("!raw-loader!./assets/UnionInSets.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 2], notes: "" },
    { lines: [5], notes: "" },
    { lines: [6], notes: "" },
    { range: [6, 6 + 3], notes: "" },
  ]}
/>

```notes
tillbaka till skolan, m√§ngdl√§ra

addition och ta bort dubletter

union, syskon till produkt
```

---

<CodeSurfer
  title="Interface som en produkt"
  code={require("!raw-loader!./assets/InterfaceAsAProduct.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 3], notes: "" },
    { lines: [6], notes: "" },
    { lines: [8], notes: "" },
    { lines: [10], notes: "" },
    { lines: [11], notes: "" },
    { lines: [12], notes: "" },
    { lines: [13], notes: "" },
    { range: [8, 8 + 5], notes: "2 x 2 = 4" },
    { range: [1, 13], notes: "(1 + 1) x (1 + 1) = 4" },
  ]}
/>

```notes
Om | √§r union, d√• √§r interface en produkt
```

---

## ü§ô ‚ûû üåÄ ‚ûû üìä

<Appear>
  <div>{"{loading: false, data: null}"} ü§ô</div>
  <div>{"{loading: true, data: null}"} üåÄ</div>
  <div>{"{loading: false, data: data}"} üìä</div>
  <div>...</div>
  <div>{"{loading: true, data: data}"} üêõ</div>
</Appear>

```notes
G√• tillbaka till v√•r app

initialt v√§rde

skicka fr√•gan, visa spinner

f√• tillbaka, visa data

...

men det fj√§rde d√•? bug!

"trivialt", men om det existerar buggar i detta kontext, under hur mycket det finns i st√∂rre applikationer
```

---

## Varf√∂r? - "Making illegale state unrepresentable"

### üß® üêõ

```notes
3 states enligt krav, 4 enligt koden

dags att d√∂da buggen

med det vi l√§rt oss om produkter, unioner och TypeScript
```

---

<Appear>
  <div>3 = x * y</div>
  <div>3 = x + y</div>
  <div>3 = 2 + 1</div>
  <br />
  <div>2 = 1 + 1</div>
  <div>3 = 1 + 1 + 1</div>
</Appear>

```notes
produkt eller summa? heltal! inga halva typer
```

---

<CodeSurfer
  title="Interface som en produkt"
  code={require("!raw-loader!./assets/UnionSolve1.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { lines: [1], notes: "" },
    { lines: [3], notes: "" },
    { range: [5, 5 + 1], notes: "" },
    { range: [8, 8 + 2], notes: "" },
  ]}
/>

```notes
union till r√§ddning

ganska l√§tt att r√§kna
```

---

## ...

---

## Varf√∂r? - Refaktorering

```notes
jag har ett nytt f√∂rslag
```

---

## Diskriminering

```notes
men, jag har ett f√∂rslag

vi ska diskriminera...

v√•ra unioner
```

---

<CodeSurfer
  title="Diskriminerad Union"
  code={require("!raw-loader!./assets/DiscriminatedUnion.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 6], notes: "" },
    { range: [9, 9 + 6], notes: "" },
    { range: [17, 17 + 8], notes: "" },
    { lines: [27], notes: "" },
  ]}
/>

```notes

```

---

<CodeSurfer
  title="ü§ô ‚ûû üåÄ ‚ûû üìä"
  code={require("!raw-loader!./assets/DiscriminatedSwitch.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 26], notes: "" },
    { lines: [29], notes: "" },
    { range: [31, 31 + 1], notes: "" },
    { range: [34, 34 + 2], notes: "" },
    { range: [38, 38 + 9], notes: "" },
  ]}
/>

```notes

```

---

<CodeSurfer
  title="Refaktorering"
  code={require("!raw-loader!./assets/DiscriminatedSwitch2.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[{ range: [1, 1 + 5], notes: "" }, { range: [8, 8 + 9], notes: "" }]}
/>

```notes
vi vill hantera fel, l√§gg till det!

oj, koden kompilerar inte, undefined !== string

vi TVINGAS hantera switchen

"exhaustive pattern matching"
```

---

## Vad har vi l√§rt oss?

<Appear>
  <div>TypeScript, delvis!</div>
  <div>Polymorphism</div>
  <div>M√§ngdl√§ra, Unioner och Produkter</div>
  <div>Diskriminerade Unioner</div>
</Appear>

```notes
type inference, typannoteringar, skapa v√•ra egna typer

typer som tar typer som parameter, listor t.ex.
```

---

## Buzzword-check!

<Appear>
  <h3>Simplare</h3>
  <div>3 &lt; 4</div>
  <h3>L√§ttare att f√∂r√§ndra</h3>
  <div>Exhaustive pattern matching</div>
  <h3>Korrektare</h3>
  <div>4 != 3</div>
</Appear>

```notes
f√∂rm√•gan att utrycka MINDRE √§r underskattad

vi tvingas hantera alla nya fall
```

---

## "Popul√§ra diskriminerade unioner"

```notes
illustrering av discriminated union i andra spr√•k

koncept i spr√•k som Haskell, Ocaml, Rust, nu i Java
```

---

<CodeSurfer
  title="Diskriminerade unioner"
  code={require("!raw-loader!./assets/Maybe.ts")}
  dark={dark}
  lang="typescript"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 9], notes: "" },
    { range: [11, 11 + 11], notes: "" },
    {},
  ]}
/>

```notes
Optional i Java, ist√§llet f√∂r null

F√∂r att h√§mta pekare i Rust, inga null pointers!

I spr√•k d√§r null inte finns, t.ex. Haskell eller OCaml
```

---

## ...

---

---

## "... | ReasonML" ?

---

<CodeSurfer
  title="ReasonML"
  code={require("!raw-loader!./assets/Reason.re")}
  dark={dark}
  lang="reason"
  theme={codeTheme}
  showNumbers={false}
  steps={[
    { range: [1, 1 + 4], notes: "" },
    { range: [6, 6 + 7], notes: "" },
    {},
  ]}
/>

```notes
Statiskt typad funktionellt programmeringsspr√•k som kompileras till JS

Inget speciellt beh√∂vs f√∂r diskriminerade unioner

b√§ttre type inference, den gissa b√§ttre

Expressions ist√§llet f√∂r statements

Default immutability

TypeScript √§r jobb
Det h√§r √§r coolt

Mer saker jag inte hinner ber√§tta om!
```

---

## https://reasonml.github.io/

---

# Tack f√∂r att ni lyssnade‚ù£Ô∏è
